<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#00ff88">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GPTARD">
    <title>GPTARD - Your personal trenching assistant</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="logo.png.png">
    <link rel="icon" type="image/png" sizes="16x16" href="logo.png.png">
    <link rel="apple-touch-icon" href="logo.png.png">
    <link rel="shortcut icon" href="logo.png.png">
    <link rel="icon" type="image/x-icon" href="logo.png.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                fontFamily: { inter: ["Inter", "sans-serif"], grotesk: ["Space Grotesk", "sans-serif"] },
                extend: {
                    colors: {
                        background: '#0a0a0a',
                        foreground: '#ffffff',
                        primary: '#00ff88',
                        secondary: '#18181b',
                        accent: '#7f5af0',
                        muted: '#222',
                    },
                },
            },
        }
    </script>
    <style>
        html, body { height: 100%; }
        body {
            font-family: 'Inter', sans-serif;
            color: rgb(255, 255, 255);
            background: linear-gradient(135deg, #0a0a0a 0%, #18181b 60%, #232347 100%);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Crypto Charts Background */
        .crypto-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
            pointer-events: none;
        }
        
        .chart-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .chart-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #00ff88, #7f5af0);
            border-radius: 1px;
            animation: chartMove 20s linear infinite;
        }
        
        .chart-line:nth-child(1) {
            top: 20%;
            width: 60%;
            animation-delay: 0s;
        }
        
        .chart-line:nth-child(2) {
            top: 40%;
            width: 80%;
            animation-delay: -5s;
        }
        
        .chart-line:nth-child(3) {
            top: 60%;
            width: 45%;
            animation-delay: -10s;
        }
        
        .chart-line:nth-child(4) {
            top: 80%;
            width: 70%;
            animation-delay: -15s;
        }
        
        @keyframes chartMove {
            0% { transform: translateX(-100%); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateX(100vw); opacity: 0; }
        }
        
        /* Floating Crypto Particles */
        .crypto-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            color: #00ff88;
            font-size: 24px;
            font-weight: bold;
            opacity: 0.15;
            animation: float 15s linear infinite;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .particle:nth-child(odd) {
            color: #7f5af0;
            text-shadow: 0 0 10px rgba(127, 90, 240, 0.5);
        }
        
        .particle:nth-child(3n) {
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.15;
            }
            90% {
                opacity: 0.15;
            }
            100% {
                transform: translateY(-100px) translateX(100px) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Different animation delays for variety */
        .particle:nth-child(1) { animation-delay: 0s; animation-duration: 20s; }
        .particle:nth-child(2) { animation-delay: 2s; animation-duration: 18s; }
        .particle:nth-child(3) { animation-delay: 4s; animation-duration: 22s; }
        .particle:nth-child(4) { animation-delay: 6s; animation-duration: 16s; }
        .particle:nth-child(5) { animation-delay: 8s; animation-duration: 24s; }
        .particle:nth-child(6) { animation-delay: 10s; animation-duration: 19s; }
        .particle:nth-child(7) { animation-delay: 12s; animation-duration: 21s; }
        .particle:nth-child(8) { animation-delay: 14s; animation-duration: 17s; }
        .particle:nth-child(9) { animation-delay: 16s; animation-duration: 23s; }
        .particle:nth-child(10) { animation-delay: 18s; animation-duration: 20s; }
        .particle:nth-child(11) { animation-delay: 20s; animation-duration: 18s; }
        .particle:nth-child(12) { animation-delay: 22s; animation-duration: 25s; }
        .particle:nth-child(13) { animation-delay: 24s; animation-duration: 19s; }
        .particle:nth-child(14) { animation-delay: 26s; animation-duration: 22s; }
        .particle:nth-child(15) { animation-delay: 28s; animation-duration: 21s; }
        
        /* Mobile optimization for particles */
        @media (max-width: 768px) {
            .particle {
                font-size: 18px;
                opacity: 0.1;
            }
        }
        
        /* Price Ticker */
        .price-ticker {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(24, 24, 27, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #333;
            z-index: 40;
            overflow: hidden;
            height: 40px;
        }
        
        .ticker-container {
            display: flex;
            animation: tickerScroll 60s linear infinite;
            white-space: nowrap;
        }
        
        .ticker-item {
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 600;
            min-width: 220px;
            gap: 8px;
        }
        
        .ticker-symbol {
            color: #00ff88;
            font-weight: 800;
            min-width: 35px;
        }
        
        .ticker-price {
            color: #fff;
            font-weight: 600;
            min-width: 80px;
            text-align: right;
        }
        
        .ticker-change {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 700;
        }
        
        .ticker-change.positive {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .ticker-change.negative {
            background: rgba(255, 59, 48, 0.2);
            color: #ff3b30;
        }
        
        @keyframes tickerScroll {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }
        
        /* Adjust header position for ticker */
        header {
            top: 40px !important;
        }
        
        /* Adjust main content for ticker */
        main {
            padding-top: 120px !important;
        }
        
        /* Mobile optimizations for ticker */
        @media (max-width: 768px) {
            .price-ticker {
                height: 36px;
            }
            
            .ticker-item {
                padding: 0 12px;
                font-size: 11px;
                min-width: 140px;
                gap: 6px;
            }
            
            .ticker-symbol {
                min-width: 30px;
            }
            
            .ticker-price {
                min-width: 60px;
            }
            
            .ticker-change {
                padding: 1px 4px;
                font-size: 10px;
            }
            
            header {
                top: 36px !important;
            }
            
            main {
                padding-top: 110px !important;
            }
        }
        h1, h2, h3, h4, .font-grotesk { font-family: 'Space Grotesk', sans-serif; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #18181b; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .divider {
            width: 100vw;
            height: 32px;
            display: block;
        }
        .section-fade { opacity: 0; transform: translateY(40px); transition: opacity 1s, transform 1s; }
        .section-fade.visible { opacity: 1; transform: translateY(0); }
        .gradient-bar {
            height: 4px;
            width: 64px;
            margin: 0.5rem auto 1.5rem auto;
            border-radius: 2px;
            background: linear-gradient(90deg, #00ff88 0%, #7f5af0 100%);
        }
        .scroll-to-top {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 100;
            background: linear-gradient(90deg, #00ff88 0%, #7f5af0 100%);
            color: #0a0a0a;
            border-radius: 9999px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.9;
            border: none;
            transition: opacity 0.2s, transform 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .scroll-to-top:hover, .scroll-to-top:active {
            opacity: 1;
            transform: scale(1.1);
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .scroll-to-top {
                bottom: 1.5rem;
                right: 1.5rem;
                width: 52px;
                height: 52px;
            }
            
            body {
                -webkit-text-size-adjust: 100%;
                -webkit-font-smoothing: antialiased;
            }
            
            /* Improve touch targets */
            button, a {
                min-height: 44px;
                min-width: 44px;
            }
            
            /* Better spacing on mobile */
            .section-fade {
                margin-bottom: 2rem;
            }
            
            /* Optimize header for mobile */
            header {
                padding: 0.75rem 1rem;
            }
            
            /* Better button sizing */
            .bg-primary, .bg-secondary {
                padding: 0.875rem 1.5rem;
                font-size: 1rem;
            }
        }
        
        /* Prevent zoom on input focus */
        input, textarea, select {
            font-size: 16px;
        }
        .badge-solana {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: #18181b;
            border: 1px solid #00ff88;
            color: #00ff88;
            border-radius: 9999px;
            padding: 0.25rem 1rem;
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        .badge-solana svg {
            width: 1.2em;
            height: 1.2em;
        }
    </style>
</head>
<body class="bg-background text-foreground">
    <!-- Crypto Charts Background -->
    <div class="crypto-background">
        <div class="chart-container">
            <div class="chart-line"></div>
            <div class="chart-line"></div>
            <div class="chart-line"></div>
            <div class="chart-line"></div>
        </div>
    </div>
    
    <!-- Floating Crypto Particles -->
    <div class="crypto-particles" id="cryptoParticles">
        <div class="particle">₿</div>
        <div class="particle">Ξ</div>
        <div class="particle">◎</div>
        <div class="particle">₳</div>
        <div class="particle">●</div>
        <div class="particle">◈</div>
        <div class="particle">◆</div>
        <div class="particle">◇</div>
        <div class="particle">★</div>
        <div class="particle">♦</div>
        <div class="particle">♠</div>
        <div class="particle">♣</div>
        <div class="particle">♥</div>
        <div class="particle">⚡</div>
        <div class="particle">💎</div>
    </div>
    
    <!-- Price Ticker -->
    <div class="price-ticker">
        <div class="ticker-container" id="tickerContainer">
            <!-- Ticker items will be populated by JavaScript -->
        </div>
    </div>
    
    <div class="min-h-screen flex flex-col justify-between">
        <!-- Header -->
        <header class="fixed top-0 left-0 right-0 bg-secondary/90 backdrop-blur border-b border-muted z-50 shadow-sm">
            <div class="max-w-5xl mx-auto px-4 py-3 md:py-4 flex justify-between items-center">
                <div class="flex items-center space-x-2 md:space-x-3">
                    <div class="relative">
                        <img src="logo.png.png" alt="GPTARD Logo" style="max-height: 40px; width: auto;" class="md:max-h-12 rounded-full bg-secondary border border-muted shadow-lg opacity-90 hover:opacity-100 transition-opacity duration-300" />
                        <div class="absolute inset-0 rounded-full bg-gradient-to-br from-primary/20 to-accent/20 opacity-0 hover:opacity-100 transition-opacity duration-300"></div>
                    </div>
                    <div class="flex flex-col md:flex-row md:items-center md:space-x-3">
                        <h1 class="text-lg md:text-2xl font-extrabold text-foreground tracking-tight font-grotesk">GPTARD</h1>
                        <span class="text-xs md:text-sm text-gray-400 font-semibold hidden sm:block">gptard.wtf</span>
                    </div>
                </div>
                <div class="hidden md:flex items-center space-x-6">
                    <a href="#tools" class="text-gray-300 hover:text-primary transition-colors font-semibold">Tools</a>
                    <a href="#token" class="text-gray-300 hover:text-primary transition-colors font-semibold">Token</a>
                </div>
                <button
                    onclick="connectWallet()"
                    id="connectBtn"
                    class="bg-primary text-black px-4 md:px-6 py-2 rounded-lg font-semibold shadow-sm hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary border border-transparent text-sm md:text-base"
                >
                    <span class="hidden sm:inline">Connect Wallet</span>
                    <span class="sm:hidden">Connect</span>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 pt-32 md:pt-40 pb-16 md:pb-24 px-4">
            <div class="max-w-5xl mx-auto">
                <!-- Hero Section -->
                <section class="flex flex-col items-center text-center mb-12 md:mb-16 section-fade">
                    <span class="badge-solana">
                        <svg viewBox="0 0 40 40" fill="none"><rect width="40" height="40" rx="20" fill="#18181b"/><g><rect x="10" y="13" width="20" height="3" rx="1.5" fill="#00ff88"/><rect x="10" y="19" width="20" height="3" rx="1.5" fill="#7f5af0"/><rect x="10" y="25" width="20" height="3" rx="1.5" fill="#00ff88"/></g></svg>
                        Live on Solana
                    </span>
                    <div class="relative mb-4 md:mb-6">
                        <img src="logo.png.png" alt="GPTARD Logo" style="max-height: 72px; width: auto;" class="md:max-h-24 rounded-full bg-secondary border-4 border-muted shadow-xl opacity-90 hover:opacity-100 transition-all duration-300 hover:scale-105" />
                        <div class="absolute inset-0 rounded-full bg-gradient-to-br from-primary/30 to-accent/30 opacity-0 hover:opacity-100 transition-opacity duration-300"></div>
                    </div>
                    <h1 class="text-4xl md:text-6xl lg:text-7xl font-extrabold text-foreground mb-3 md:mb-4 tracking-tight font-grotesk">GPTARD</h1>
                    <div class="gradient-bar"></div>
                    <p class="text-xl md:text-2xl lg:text-3xl text-gray-200 mb-3 md:mb-4 font-semibold font-grotesk">Your personal trenching assistant</p>
                    <p class="text-base md:text-lg text-gray-400 mb-6 md:mb-8 max-w-2xl mx-auto px-2">Trained by the trenches, for the trenches. Token-gated privacy. Built for the Solana community. Hold $GPTARD to unlock exclusive access to the most advanced AI chatbot on-chain.</p>
                    <div class="flex flex-col sm:flex-row gap-3 md:gap-4 justify-center w-full max-w-md mx-auto mb-6">
                        <button onclick="connectWallet()" id="heroConnectBtn" class="bg-primary text-black px-6 md:px-8 py-3 md:py-4 rounded-lg text-lg md:text-xl font-bold shadow-sm hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary border border-transparent font-grotesk w-full sm:w-auto">Connect Wallet</button>
                        <a href="#token" class="bg-secondary border border-primary text-primary px-6 md:px-8 py-3 md:py-4 rounded-lg text-lg md:text-xl font-bold shadow-sm hover:bg-primary hover:text-black transition-colors focus:outline-none focus:ring-2 focus:ring-primary font-grotesk w-full sm:w-auto text-center">Get $GPTARD</a>
                    </div>
                    <button onclick="openFullChat()" class="bg-gradient-to-r from-primary to-accent text-black px-8 md:px-12 py-4 md:py-5 rounded-xl text-xl md:text-2xl font-bold shadow-lg hover:shadow-xl transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-primary/50 border border-transparent font-grotesk transform hover:scale-105 animate-pulse">
                        🚀 Start Chat with GPTARD
                    </button>
                </section>

                <!-- Features Section -->
                <section class="mb-12 md:mb-16 section-fade">
                    <h2 class="text-2xl md:text-3xl font-extrabold text-foreground mb-2 text-center tracking-tight flex items-center justify-center gap-2 font-grotesk"><span>Why Choose GPTARD?</span> <span class="text-accent">★</span></h2>
                    <div class="gradient-bar"></div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-8">
                        <div class="bg-secondary rounded-xl p-6 md:p-8 border border-muted shadow-sm flex flex-col items-center hover:bg-muted/60 transition-colors">
                            <span class="text-3xl md:text-4xl mb-3 md:mb-4">🤖</span>
                            <h3 class="text-lg md:text-xl font-bold mb-2 font-grotesk text-center">Trained by the trenches, for the trenches</h3>
                            <p class="text-gray-400 text-sm md:text-base text-center">Get instant, intelligent answers 24/7. No limits, no nonsense.</p>
                        </div>
                        <div class="bg-secondary rounded-xl p-6 md:p-8 border border-muted shadow-sm flex flex-col items-center hover:bg-muted/60 transition-colors">
                            <span class="text-3xl md:text-4xl mb-3 md:mb-4">🔒</span>
                            <h3 class="text-lg md:text-xl font-bold mb-2 font-grotesk text-center">Token-Gated Access</h3>
                            <p class="text-gray-400 text-sm md:text-base text-center">Only $GPTARD holders can chat. Your privacy, your control.</p>
                        </div>
                        <div class="bg-secondary rounded-xl p-6 md:p-8 border border-muted shadow-sm flex flex-col items-center hover:bg-muted/60 transition-colors">
                            <span class="text-3xl md:text-4xl mb-3 md:mb-4">⚡</span>
                            <h3 class="text-lg md:text-xl font-bold mb-2 font-grotesk text-center">Solana Fast & Cheap</h3>
                            <p class="text-gray-400 text-sm md:text-base text-center">Enjoy lightning-fast, low-cost transactions on the Solana blockchain.</p>
                        </div>
                        <div class="bg-secondary rounded-xl p-6 md:p-8 border border-muted shadow-sm flex flex-col items-center hover:bg-muted/60 transition-colors">
                            <span class="text-3xl md:text-4xl mb-3 md:mb-4">🛡️</span>
                            <h3 class="text-lg md:text-xl font-bold mb-2 font-grotesk text-center">Private & Secure</h3>
                            <p class="text-gray-400 text-sm md:text-base text-center">No tracking, no ads, no leaks. Your data stays yours.</p>
                        </div>
                    </div>
                </section>

                <!-- How It Works Section -->
                <section class="mb-16 section-fade">
                    <h2 class="text-3xl font-extrabold text-foreground mb-2 text-center tracking-tight flex items-center justify-center gap-2"><span>How It Works</span> <span class="text-accent">⚙️</span></h2>
                    <div class="gradient-bar"></div>
                    <div class="flex flex-col md:flex-row gap-8 justify-center items-center">
                        <div class="bg-secondary flex flex-col items-center p-6 rounded-xl border border-muted shadow-sm">
                            <div class="bg-primary text-black rounded-full w-16 h-16 flex items-center justify-center text-3xl font-bold mb-2 shadow">1</div>
                            <div class="text-lg font-semibold mb-1">Connect Wallet</div>
                            <div class="text-gray-400 text-center">Use Phantom or any Solana wallet to get started.</div>
                        </div>
                        <div class="hidden md:block text-4xl text-primary">→</div>
                        <div class="bg-secondary flex flex-col items-center p-6 rounded-xl border border-muted shadow-sm">
                            <div class="bg-primary text-black rounded-full w-16 h-16 flex items-center justify-center text-3xl font-bold mb-2 shadow">2</div>
                            <div class="text-lg font-semibold mb-1">Hold $GPTARD</div>
                            <div class="text-gray-400 text-center">Own at least 1000 $GPTARD tokens to unlock chat access.</div>
                        </div>
                        <div class="hidden md:block text-4xl text-primary">→</div>
                        <div class="bg-secondary flex flex-col items-center p-6 rounded-xl border border-muted shadow-sm">
                            <div class="bg-primary text-black rounded-full w-16 h-16 flex items-center justify-center text-3xl font-bold mb-2 shadow">3</div>
                            <div class="text-lg font-semibold mb-1">Chat with AI</div>
                            <div class="text-gray-400 text-center">Ask anything, get answers instantly from GPTARD.</div>
                        </div>
                    </div>
                </section>

                <!-- Token Utility Section -->
                <section id="token" class="mb-16 section-fade">
                    <h2 class="text-3xl font-extrabold text-foreground mb-2 text-center tracking-tight flex items-center justify-center gap-2"><span>Why Hold $GPTARD?</span> <span class="text-accent">💎</span></h2>
                    <div class="gradient-bar"></div>
                    <div class="flex justify-center">
                        <div class="bg-secondary rounded-xl p-8 border border-muted shadow-sm hover:bg-muted/60 transition-colors max-w-md">
                            <h3 class="text-xl font-bold mb-2 text-center">Unlock Exclusive AI Features</h3>
                            <p class="text-gray-400 text-center">Access advanced chat, early features, and premium support as a token holder.</p>
                        </div>
                    </div>
                </section>

                <!-- Trading Tools Section -->
                <section id="tools" class="mb-16 section-fade">
                    <h2 class="text-3xl font-extrabold text-foreground mb-2 text-center tracking-tight flex items-center justify-center gap-2"><span>Trading Tools</span> <span class="text-accent">🛠️</span></h2>
                    <div class="gradient-bar"></div>
                    <p class="text-gray-400 text-center mb-8 max-w-2xl mx-auto">Professional trading tools for the Solana ecosystem. Track wallets, analyze performance, and stay ahead of the market.</p>
                    
                    <!-- Tools Grid -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-12">
                        <!-- Watchlist Tool -->
                        <div class="bg-secondary rounded-xl border border-muted shadow-sm overflow-hidden">
                            <div class="p-6 border-b border-muted">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <h3 class="text-xl font-bold font-grotesk flex items-center gap-2">
                                            <span>👀</span>
                                            Degen Wallet Watchlist
                                        </h3>
                                        <p class="text-gray-400 mt-2">Track the moves of the biggest degens on Solana. Monitor wallet activity, token interactions, and transaction patterns.</p>
                                    </div>
                                    <button onclick="refreshAllWalletData()" class="bg-primary text-black px-4 py-2 rounded-lg font-semibold hover:bg-primary/90 transition-colors flex items-center space-x-2">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                        </svg>
                                        <span>Refresh</span>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Add Wallet Form -->
                            <div class="p-6 border-b border-muted">
                                <h4 class="text-lg font-bold mb-4 font-grotesk">Add Wallet to Watchlist</h4>
                                <div class="flex flex-col sm:flex-row gap-4">
                                    <input 
                                        type="text" 
                                        id="walletInput" 
                                        placeholder="Enter Solana wallet address..." 
                                        class="flex-1 bg-muted border border-gray-600 rounded-lg px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                                    >
                                    <button 
                                        onclick="addWalletToWatchlist()" 
                                        class="bg-primary text-black px-6 py-3 rounded-lg font-semibold hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Add Wallet
                                    </button>
                                </div>
                            </div>

                            <!-- Watchlist Table -->
                            <div class="overflow-x-auto">
                                <table class="w-full">
                                    <thead class="bg-muted/50">
                                        <tr>
                                            <th class="px-6 py-4 text-left text-sm font-semibold text-gray-300 border-b border-muted">Wallet Address</th>
                                            <th class="px-6 py-4 text-left text-sm font-semibold text-gray-300 border-b border-muted">Last 3 Tokens</th>
                                            <th class="px-6 py-4 text-left text-sm font-semibold text-gray-300 border-b border-muted">Last TX Time</th>
                                            <th class="px-6 py-4 text-left text-sm font-semibold text-gray-300 border-b border-muted">TX Count</th>
                                            <th class="px-6 py-4 text-left text-sm font-semibold text-gray-300 border-b border-muted">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="watchlistTableBody">
                                        <!-- Watchlist data will be populated by JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Chat Tool -->
                        <div class="bg-secondary rounded-xl border border-muted shadow-sm overflow-hidden">
                            <div class="p-6 border-b border-muted">
                                <h3 class="text-xl font-bold font-grotesk flex items-center gap-2">
                                    <span>💬</span>
                                    GPTARD AI Assistant
                                </h3>
                                <p class="text-gray-400 mt-2">Your personal trenching assistant. Get instant answers about crypto, trading strategies, and market analysis.</p>
                            </div>
                            
                            <!-- Chat Messages -->
                            <div class="h-80 overflow-y-auto p-4 space-y-4" id="chatMessages">
                                <!-- Welcome message -->
                                <div class="flex items-start space-x-3">
                                    <div class="bg-primary text-black rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold">🤖</div>
                                    <div class="bg-muted rounded-lg p-3 max-w-xs md:max-w-md">
                                        <p class="text-sm">Hey there! I'm GPTARD, your personal trenching assistant. I'm trained by the trenches, for the trenches. What can I help you with today?</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Chat Input -->
                            <div class="p-4 border-t border-muted">
                                <div class="flex space-x-3">
                                    <input 
                                        type="text" 
                                        id="chatInput" 
                                        placeholder="Ask me anything about crypto, trading, or the trenches..." 
                                        class="flex-1 bg-muted border border-gray-600 rounded-lg px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                                        maxlength="500"
                                    >
                                    <button 
                                        onclick="sendMessage()" 
                                        id="sendButton"
                                        class="bg-primary text-black px-6 py-3 rounded-lg font-semibold hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Send
                                    </button>
                                    <button 
                                        onclick="openFullChat()" 
                                        class="bg-secondary border border-primary text-primary px-4 py-3 rounded-lg font-semibold hover:bg-primary hover:text-black transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
                                        title="Open Full Chat"
                                    >
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                                        </svg>
                                    </button>
                                </div>
                                <div class="flex justify-between items-center mt-2">
                                    <p class="text-xs text-gray-400">Press Enter to send</p>
                                    <p class="text-xs text-gray-400" id="charCount">0/500</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </main>

        <!-- Footer -->
        <footer class="bg-secondary border-t border-muted py-6 md:py-8">
            <div class="max-w-5xl mx-auto px-4">
                <div class="flex flex-col md:flex-row justify-between items-center">
                    <div class="flex items-center space-x-2 md:space-x-3 mb-4 md:mb-0">
                        <div class="relative">
                            <img src="logo.png.png" alt="GPTARD Logo" style="max-height: 28px; width: auto;" class="md:max-h-8 rounded-full bg-secondary border border-muted opacity-80 hover:opacity-100 transition-opacity duration-300" />
                            <div class="absolute inset-0 rounded-full bg-gradient-to-br from-primary/15 to-accent/15 opacity-0 hover:opacity-100 transition-opacity duration-300"></div>
                        </div>
                        <span class="text-base md:text-lg font-bold font-grotesk">GPTARD</span>
                    </div>
                    <div class="flex space-x-4 md:space-x-6">
                        <a href="https://twitter.com/chatgptard" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-primary transition-colors p-2">
                            <svg class="w-5 h-5 md:w-6 md:h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                        </a>
                    </div>
                </div>
                <div class="mt-4 md:mt-6 pt-4 md:pt-6 border-t border-muted text-center">
                    <p class="text-gray-400 text-xs md:text-sm">© 2024 GPTARD. Built for the Solana community.</p>
                </div>
            </div>
        </footer>
    </div>

    <!-- Full Chat Screen -->
    <div id="fullChatScreen" class="fixed inset-0 bg-background z-50 hidden">
        <!-- Full Chat Header -->
        <div class="bg-secondary border-b border-muted p-4 flex items-center justify-between">
            <div class="flex items-center space-x-3">
                <button onclick="closeFullChat()" class="text-gray-400 hover:text-white transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                </button>
                <div class="bg-primary text-black rounded-full w-10 h-10 flex items-center justify-center text-lg font-bold">🤖</div>
                <div>
                    <h2 class="text-xl font-bold font-grotesk">GPTARD AI Assistant</h2>
                    <p class="text-sm text-gray-400">Full Chat Mode</p>
                </div>
            </div>
            <div class="flex items-center space-x-4">
                <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                    <span class="text-sm text-green-500 font-semibold">Online</span>
                </div>
                <div class="flex items-center space-x-2" id="walletStatus">
                    <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                    <span class="text-sm text-red-500 font-semibold">Wallet Disconnected</span>
                </div>
            </div>
        </div>
        
        <!-- Full Chat Messages -->
        <div class="flex-1 overflow-y-auto p-4 space-y-4" id="fullChatMessages">
            <!-- Messages will be copied here -->
        </div>
        
        <!-- Full Chat Input -->
        <div class="bg-secondary border-t border-muted p-4">
            <div class="flex space-x-3">
                <input 
                    type="text" 
                    id="fullChatInput" 
                    placeholder="Ask me anything about crypto, trading, or the trenches..." 
                    class="flex-1 bg-muted border border-gray-600 rounded-lg px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                    maxlength="500"
                >
                <button 
                    onclick="sendFullChatMessage()" 
                    id="fullSendButton"
                    class="bg-primary text-black px-6 py-3 rounded-lg font-semibold hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Send
                </button>
            </div>
            <div class="flex justify-between items-center mt-2">
                <p class="text-xs text-gray-400">Press Enter to send</p>
                <p class="text-xs text-gray-400" id="fullCharCount">0/500</p>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <button onclick="scrollToTop()" class="scroll-to-top" id="scrollToTop" style="display: none;">
        ↑
    </button>

    <script>
        // Intersection Observer for fade-in animations
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, observerOptions);

        document.querySelectorAll('.section-fade').forEach(section => {
            observer.observe(section);
        });

        // Scroll to top functionality
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Show/hide scroll to top button
        window.addEventListener('scroll', () => {
            const scrollBtn = document.getElementById('scrollToTop');
            if (window.scrollY > 300) {
                scrollBtn.style.display = 'flex';
            } else {
                scrollBtn.style.display = 'none';
            }
        });

        // Wallet connection placeholder
        function connectWallet() {
            alert('Wallet connection coming soon! This will integrate with Solana wallets like Phantom.');
        }

        // Chat functionality
        let isTyping = false;
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const charCount = document.getElementById('charCount');

        // Enhanced responses with conversation memory and crypto data
        let conversationHistory = [];
        let userPreferences = {
            experience: 'beginner',
            interests: [],
            lastTopics: []
        };

        const gptardResponses = {
            // Basic interactions
            'hello': "Hey there! Welcome to the trenches. I'm GPTARD, your AI assistant trained by the community. What's on your mind?",
            'hi': "Hi! Ready to dive into the crypto world? What can I help you with today?",
            'hey': "Hey! What's happening in your crypto journey?",
            
            // Solana ecosystem
            'solana': "Solana is the future! Lightning-fast transactions (65,000 TPS), sub-penny fees, and the best developer ecosystem. The SOL community is building the next generation of DeFi. What specific aspect interests you - DeFi protocols, NFTs, or development?",
            'sol': "SOL is the native token of Solana. It's used for staking, governance, and paying transaction fees. With its proof-of-stake consensus, you can earn rewards by staking your SOL. Want to know more about staking or current SOL metrics?",
            
            // Trading and strategy
            'trading': "Trading in the trenches requires patience and strategy. Always DYOR (Do Your Own Research), never invest more than you can afford to lose, and remember: the market can stay irrational longer than you can stay solvent. What's your trading experience level?",
            'strategy': "Here's my trading strategy framework: 1) Set clear goals and risk tolerance, 2) Diversify across different assets, 3) Use stop-losses, 4) Keep emotions in check, 5) Always have an exit plan. What's your current strategy?",
            'portfolio': "Portfolio management is key! Consider diversifying across: 1) Blue-chip cryptos (BTC, ETH), 2) Layer 1s (SOL, ADA), 3) DeFi tokens, 4) NFTs, 5) Stablecoins for stability. What's your current allocation?",
            
            // GPTARD specific
            'gptard': "GPTARD is the ultimate AI assistant for the Solana community! I'm trained by the trenches, for the trenches. Hold $GPTARD tokens to unlock exclusive features and premium support. The more you hold, the more powerful I become!",
            'token': "The $GPTARD token is your key to unlocking premium AI features. Hold tokens to access advanced trading insights, priority support, and exclusive community features. It's the future of AI-powered crypto assistance!",
            
            // Crypto general
            'crypto': "Crypto is the future of finance! We're building a decentralized world where you own your data, your money, and your future. The Solana ecosystem is leading the charge with blazing-fast transactions and innovative DeFi protocols.",
            'bitcoin': "Bitcoin is digital gold - the OG crypto that started it all. It's a store of value and hedge against inflation. While I'm Solana-focused, BTC is still the king of crypto and worth understanding.",
            'ethereum': "Ethereum pioneered smart contracts and DeFi. While Solana offers faster and cheaper transactions, ETH has the largest ecosystem. Both have their strengths - it's not about choosing one over the other!",
            
            // DeFi
            'defi': "DeFi on Solana is revolutionary! From Serum DEX to Raydium, the ecosystem offers lightning-fast trading with minimal fees. The composability of Solana DeFi protocols is unmatched. What DeFi protocols are you most interested in?",
            'serum': "Serum is Solana's premier DEX - lightning-fast trading with order book depth. It's the backbone of Solana DeFi, offering spot and futures trading with sub-second finality.",
            'raydium': "Raydium is the leading AMM on Solana, offering automated market making with concentrated liquidity. It's perfect for trading with minimal slippage and maximum efficiency.",
            'jupiter': "Jupiter is the best aggregator on Solana! It finds the best routes across all DEXs for your trades, ensuring you get the best prices and lowest fees.",
            
            // NFTs
            'nft': "NFTs on Solana are the real deal! With transaction fees under $0.01, you can mint and trade without breaking the bank. The Solana NFT community is vibrant and growing fast. Are you an artist, collector, or just curious?",
            'magiceden': "Magic Eden is the #1 NFT marketplace on Solana. It offers the best selection, lowest fees, and most active community. Perfect for discovering new projects and trading NFTs.",
            
            // Technical
            'gas': "Gas fees on Solana are incredibly low - typically under $0.01 per transaction! Compare that to Ethereum's $50+ fees. That's why Solana is perfect for DeFi and NFT trading.",
            'speed': "Solana processes 65,000 transactions per second with sub-second finality. That's faster than Visa! No more waiting for confirmations or paying high fees.",
            
            // Market sentiment
            'bull': "Bull markets are exciting but dangerous! Remember to take profits and don't get greedy. The best traders know when to exit. What's your profit-taking strategy?",
            'bear': "Bear markets are for building and accumulating! Focus on fundamentals, DCA into quality projects, and use the time to learn. What are you doing to prepare for the next bull run?",
            
            // Help and guidance
            'help': "I'm here to help! I can assist with crypto questions, trading strategies, Solana ecosystem info, DeFi protocols, NFT guidance, and general trench wisdom. Just ask me anything!",
            'beginner': "Welcome to crypto! Start with the basics: 1) Learn about blockchain technology, 2) Understand Bitcoin and Ethereum, 3) Explore Solana's advantages, 4) Practice with small amounts, 5) Join communities like ours!",
            'advanced': "For advanced users, focus on: 1) DeFi yield strategies, 2) MEV and arbitrage opportunities, 3) Protocol governance, 4) Technical analysis, 5) Building on Solana. What's your expertise level?",
            
            'default': "Interesting question! As your trench assistant, I'm here to help with crypto insights, trading strategies, and Solana ecosystem knowledge. Could you be more specific about what you'd like to know?"
        };

        function sendMessage() {
            const message = chatInput.value.trim();
            if (!message || isTyping) return;

            // Use shared message sending logic
            sendMessageFromInput(message, 'main');
            chatInput.value = '';
            updateCharCount();
        }

        function addMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex items-start space-x-3';
            
            if (sender === 'user') {
                messageDiv.className += ' justify-end';
                messageDiv.innerHTML = `
                    <div class="bg-primary text-black rounded-lg p-3 max-w-xs md:max-w-md">
                        <p class="text-sm">${escapeHtml(text)}</p>
                    </div>
                    <div class="bg-primary text-black rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold">U</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="bg-primary text-black rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold">🤖</div>
                    <div class="bg-muted rounded-lg p-3 max-w-xs md:max-w-md">
                        <p class="text-sm">${escapeHtml(text)}</p>
                        <div class="flex space-x-2 mt-2">
                            <button onclick="rateResponse(this, 'helpful')" class="text-xs text-gray-400 hover:text-green-500 transition-colors">👍 Helpful</button>
                            <button onclick="rateResponse(this, 'not-helpful')" class="text-xs text-gray-400 hover:text-red-500 transition-colors">👎 Not Helpful</button>
                        </div>
                    </div>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }
        
        function rateResponse(button, rating) {
            // Disable both buttons to prevent multiple ratings
            const buttons = button.parentElement.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);
            
            // Visual feedback
            if (rating === 'helpful') {
                button.textContent = '👍 Thanks!';
                button.classList.add('text-green-500');
            } else {
                button.textContent = '👎 Thanks!';
                button.classList.add('text-red-500');
            }
            
            // Store feedback for improvement (in a real app, this would go to a database)
            const feedback = {
                rating: rating,
                message: conversationHistory[conversationHistory.length - 1]?.content || '',
                timestamp: Date.now()
            };
            
            console.log('User feedback:', feedback);
            
            // In a real implementation, you'd send this to your backend
            // fetch('/api/feedback', { method: 'POST', body: JSON.stringify(feedback) });
        }

        async function generateResponse(message) {
            const lowerMessage = message.toLowerCase();
            
            // Update conversation history
            conversationHistory.push({ role: 'user', content: message, timestamp: Date.now() });
            
            // Extract user interests and experience level
            updateUserPreferences(lowerMessage);
            
            // Get current crypto prices for context
            let cryptoContext = '';
            try {
                const solPrice = tickerPrices['SOL']?.price;
                const btcPrice = tickerPrices['BTC']?.price;
                if (solPrice && btcPrice) {
                    cryptoContext = ` Current prices: SOL $${parseFloat(solPrice).toFixed(2)}, BTC $${parseFloat(btcPrice).toLocaleString()}.`;
                }
            } catch (error) {
                console.log('Could not fetch crypto context');
            }
            
            // Check for keywords with enhanced logic
            let response = '';
            let matchedKeywords = [];
            
            for (const [keyword, baseResponse] of Object.entries(gptardResponses)) {
                if (lowerMessage.includes(keyword)) {
                    matchedKeywords.push(keyword);
                }
            }
            
            // Choose best response based on context
            if (matchedKeywords.length > 0) {
                const primaryKeyword = matchedKeywords[0];
                response = gptardResponses[primaryKeyword];
                
                // Add context based on conversation history
                if (conversationHistory.length > 2) {
                    const lastTopics = userPreferences.lastTopics.slice(-3);
                    if (lastTopics.includes('trading') && (primaryKeyword === 'solana' || primaryKeyword === 'sol')) {
                        response += " Since you're interested in trading, consider that SOL's volatility can present both opportunities and risks. Always use proper risk management!";
                    }
                    if (lastTopics.includes('defi') && primaryKeyword === 'portfolio') {
                        response += " Given your DeFi interest, you might want to allocate some of your portfolio to DeFi protocols like Raydium, Serum, or Orca for yield farming opportunities.";
                    }
                }
                
                // Add crypto price context
                if (cryptoContext && (primaryKeyword === 'solana' || primaryKeyword === 'sol' || primaryKeyword === 'trading')) {
                    response += cryptoContext;
                }
            } else {
                // Generate contextual response based on conversation history
                response = generateContextualResponse(lowerMessage);
            }
            
            // Update conversation history
            conversationHistory.push({ role: 'assistant', content: response, timestamp: Date.now() });
            
            // Keep only last 10 messages for memory
            if (conversationHistory.length > 10) {
                conversationHistory = conversationHistory.slice(-10);
            }
            
            return response;
        }
        
        function updateUserPreferences(message) {
            // Detect experience level
            if (message.includes('beginner') || message.includes('new') || message.includes('start')) {
                userPreferences.experience = 'beginner';
            } else if (message.includes('advanced') || message.includes('expert') || message.includes('professional')) {
                userPreferences.experience = 'advanced';
            }
            
            // Detect interests
            const interests = ['trading', 'defi', 'nft', 'staking', 'yield', 'arbitrage', 'governance'];
            interests.forEach(interest => {
                if (message.includes(interest) && !userPreferences.interests.includes(interest)) {
                    userPreferences.interests.push(interest);
                }
            });
            
            // Update last topics
            const topics = ['solana', 'trading', 'defi', 'nft', 'portfolio', 'crypto', 'bitcoin', 'ethereum'];
            topics.forEach(topic => {
                if (message.includes(topic)) {
                    userPreferences.lastTopics.push(topic);
                    if (userPreferences.lastTopics.length > 5) {
                        userPreferences.lastTopics = userPreferences.lastTopics.slice(-5);
                    }
                }
            });
        }
        
        function generateContextualResponse(message) {
            // Generate response based on user preferences and conversation context
            if (userPreferences.experience === 'beginner') {
                if (message.includes('what') || message.includes('how')) {
                    return "Great question! As a beginner, I'd recommend starting with the basics. Have you learned about blockchain technology yet? Understanding the fundamentals will help you make better decisions in crypto.";
                }
                return "I'm here to help you learn! Since you're new to crypto, I'd suggest starting with understanding Bitcoin and Ethereum first, then exploring Solana's advantages. What specific topic would you like to dive into?";
            }
            
            if (userPreferences.experience === 'advanced') {
                if (message.includes('strategy') || message.includes('opportunity')) {
                    return "For advanced strategies, consider exploring MEV opportunities, yield farming across multiple protocols, or participating in governance. What specific advanced topic interests you?";
                }
                return "As an advanced user, you might be interested in DeFi yield strategies, protocol governance, or building on Solana. What's your current focus area?";
            }
            
            // Check if user is asking about something in their interests
            for (const interest of userPreferences.interests) {
                if (message.includes(interest)) {
                    return `I see you're interested in ${interest}! Based on our conversation, I can provide more specific insights. What aspect of ${interest} would you like to explore further?`;
                }
            }
            
            return gptardResponses.default;
        }

        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function updateCharCount() {
            const count = chatInput.value.length;
            charCount.textContent = `${count}/500`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Full chat functionality
        function openFullChat() {
            // Check if wallet is connected
            if (!isWalletConnected) {
                showNotification('Please connect your wallet first to access the chat.', 'error');
                return;
            }
            
            const fullChatScreen = document.getElementById('fullChatScreen');
            const fullChatMessages = document.getElementById('fullChatMessages');
            const fullChatInput = document.getElementById('fullChatInput');
            
            // Copy existing messages to full chat
            fullChatMessages.innerHTML = chatMessages.innerHTML;
            
            // Show full chat screen
            fullChatScreen.classList.remove('hidden');
            fullChatScreen.classList.add('flex', 'flex-col');
            
            // Focus on input
            setTimeout(() => {
                fullChatInput.focus();
            }, 100);
            
            // Scroll to bottom
            fullChatMessages.scrollTop = fullChatMessages.scrollHeight;
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }
        
        function closeFullChat() {
            const fullChatScreen = document.getElementById('fullChatScreen');
            
            // Hide full chat screen
            fullChatScreen.classList.add('hidden');
            fullChatScreen.classList.remove('flex', 'flex-col');
            
            // Restore body scroll
            document.body.style.overflow = '';
            
            // Focus back on main chat input
            chatInput.focus();
        }
        
        function sendFullChatMessage() {
            const fullChatInput = document.getElementById('fullChatInput');
            const message = fullChatInput.value.trim();
            if (!message || isTyping) return;
            
            // Send message using existing logic
            sendMessageFromInput(message, 'fullChat');
            fullChatInput.value = '';
            updateFullCharCount();
        }
        
        function sendMessageFromInput(message, source = 'main') {
            const targetMessages = source === 'fullChat' ? 
                document.getElementById('fullChatMessages') : 
                document.getElementById('chatMessages');
            
            // Add user message
            addMessageToContainer(message, 'user', targetMessages);
            
            // Simulate typing
            const sendButton = source === 'fullChat' ? 
                document.getElementById('fullSendButton') : 
                document.getElementById('sendButton');
            
            sendButton.disabled = true;
            sendButton.textContent = 'Typing...';
            
            // Add typing indicator
            const typingDiv = document.createElement('div');
            typingDiv.className = 'flex items-start space-x-3';
            typingDiv.innerHTML = `
                <div class="bg-primary text-black rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold">🤖</div>
                <div class="bg-muted rounded-lg p-3">
                    <div class="flex space-x-1">
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                    </div>
                </div>
            `;
            targetMessages.appendChild(typingDiv);
            scrollToBottomOf(targetMessages);
            
            // Simulate response delay
            setTimeout(async () => {
                targetMessages.removeChild(typingDiv);
                const response = await generateResponse(message);
                addMessageToContainer(response, 'bot', targetMessages);
                sendButton.disabled = false;
                sendButton.textContent = 'Send';
            }, 1500 + Math.random() * 1000);
        }
        
        function addMessageToContainer(text, sender, container) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex items-start space-x-3';
            
            if (sender === 'user') {
                messageDiv.className += ' justify-end';
                messageDiv.innerHTML = `
                    <div class="bg-primary text-black rounded-lg p-3 max-w-xs md:max-w-md">
                        <p class="text-sm">${escapeHtml(text)}</p>
                    </div>
                    <div class="bg-primary text-black rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold">U</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="bg-primary text-black rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold">🤖</div>
                    <div class="bg-muted rounded-lg p-3 max-w-xs md:max-w-md">
                        <p class="text-sm">${escapeHtml(text)}</p>
                        <div class="flex space-x-2 mt-2">
                            <button onclick="rateResponse(this, 'helpful')" class="text-xs text-gray-400 hover:text-green-500 transition-colors">👍 Helpful</button>
                            <button onclick="rateResponse(this, 'not-helpful')" class="text-xs text-gray-400 hover:text-red-500 transition-colors">👎 Not Helpful</button>
                        </div>
                    </div>
                `;
            }
            
            container.appendChild(messageDiv);
            scrollToBottomOf(container);
        }
        
        function scrollToBottomOf(container) {
            container.scrollTop = container.scrollHeight;
        }
        
        function updateFullCharCount() {
            const fullChatInput = document.getElementById('fullChatInput');
            const fullCharCount = document.getElementById('fullCharCount');
            const count = fullChatInput.value.length;
            fullCharCount.textContent = `${count}/500`;
        }
        
        // Event listeners
        chatInput.addEventListener('input', updateCharCount);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Full chat event listeners
        const fullChatInput = document.getElementById('fullChatInput');
        fullChatInput.addEventListener('input', updateFullCharCount);
        fullChatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendFullChatMessage();
            }
        });
        
        // Close full chat with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const fullChatScreen = document.getElementById('fullChatScreen');
                if (!fullChatScreen.classList.contains('hidden')) {
                    closeFullChat();
                }
            }
        });

        // Mobile-specific optimizations
        function initMobileOptimizations() {
            // Prevent double-tap zoom on buttons
            const buttons = document.querySelectorAll('button, a');
            buttons.forEach(button => {
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    button.click();
                });
            });

            // Smooth scrolling for anchor links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });

            // Add touch feedback for mobile
            const touchElements = document.querySelectorAll('.bg-primary, .bg-secondary, .scroll-to-top');
            touchElements.forEach(element => {
                element.addEventListener('touchstart', () => {
                    element.style.transform = 'scale(0.95)';
                });
                element.addEventListener('touchend', () => {
                    element.style.transform = '';
                });
            });
        }

        // Crypto price ticker functionality
        const cryptoData = [
            { symbol: 'BTC', name: 'Bitcoin' },
            { symbol: 'ETH', name: 'Ethereum' },
            { symbol: 'SOL', name: 'Solana' },
            { symbol: 'ADA', name: 'Cardano' },
            { symbol: 'DOT', name: 'Polkadot' },
            { symbol: 'MATIC', name: 'Polygon' },
            { symbol: 'AVAX', name: 'Avalanche' },
            { symbol: 'LINK', name: 'Chainlink' },
            { symbol: 'UNI', name: 'Uniswap' },
            { symbol: 'ATOM', name: 'Cosmos' }
        ];

        let tickerPrices = {};

        // Store last successful prices to prevent flickering
        let lastSuccessfulPrices = {};
        let apiFailCount = 0;
        const MAX_API_FAILS = 3;

        async function fetchCryptoPrices() {
            try {
                // Try multiple APIs for better reliability
                let data = null;
                let apiUsed = '';
                
                // First try CoinGecko (free, no API key required)
                try {
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana,cardano,polkadot,matic-network,avalanche-2,chainlink,uniswap,cosmos&vs_currencies=usd&include_24hr_change=true', {
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        },
                        timeout: 5000
                    });
                    
                    if (response.ok) {
                        data = await response.json();
                        apiUsed = 'CoinGecko';
                        apiFailCount = 0; // Reset fail count on success
                        console.log('Using CoinGecko API');
                    }
                } catch (error) {
                    console.log('CoinGecko API failed, trying alternative...');
                }
                
                // If CoinGecko fails, try alternative API
                if (!data) {
                    try {
                        const response = await fetch('https://api.binance.com/api/v3/ticker/24hr', {
                            headers: {
                                'Accept': 'application/json'
                            },
                            timeout: 5000
                        });
                        
                        if (response.ok) {
                            const binanceData = await response.json();
                            data = convertBinanceData(binanceData);
                            apiUsed = 'Binance';
                            apiFailCount = 0; // Reset fail count on success
                            console.log('Using Binance API');
                        }
                    } catch (error) {
                        console.log('Binance API failed, trying third option...');
                    }
                }

                // If both fail, try a third option
                if (!data) {
                    try {
                        const response = await fetch('https://api.coinbase.com/v2/exchange-rates?currency=USD', {
                            headers: {
                                'Accept': 'application/json'
                            },
                            timeout: 5000
                        });
                        
                        if (response.ok) {
                            const coinbaseData = await response.json();
                            data = convertCoinbaseData(coinbaseData);
                            apiUsed = 'Coinbase';
                            apiFailCount = 0; // Reset fail count on success
                            console.log('Using Coinbase API');
                        }
                    } catch (error) {
                        console.log('Coinbase API failed, using fallback data');
                    }
                }
                
                if (data) {
                    // Map the data to our symbols
                    const priceMap = {
                        'bitcoin': 'BTC',
                        'ethereum': 'ETH',
                        'solana': 'SOL',
                        'cardano': 'ADA',
                        'polkadot': 'DOT',
                        'matic-network': 'MATIC',
                        'avalanche-2': 'AVAX',
                        'chainlink': 'LINK',
                        'uniswap': 'UNI',
                        'cosmos': 'ATOM'
                    };

                    Object.keys(data).forEach(coin => {
                        const symbol = priceMap[coin];
                        if (symbol && data[coin].usd) {
                            const newPrice = data[coin].usd;
                            const newChange = data[coin].usd_24h_change || 0;
                            
                            // Only update if we have valid data
                            if (newPrice > 0) {
                                tickerPrices[symbol] = {
                                    price: newPrice,
                                    change: newChange
                                };
                                lastSuccessfulPrices[symbol] = tickerPrices[symbol];
                            }
                        }
                    });
                } else {
                    apiFailCount++;
                    throw new Error(`All APIs failed (attempt ${apiFailCount})`);
                }

                updateTicker();
            } catch (error) {
                console.log('All APIs failed, using fallback data:', error);
                apiFailCount++;
                
                // Use last successful prices if available, otherwise use realistic fallback
                const fallbackPrices = {
                    'BTC': { price: 43250.67, change: 2.34 },
                    'ETH': { price: 2650.89, change: -1.23 },
                    'SOL': { price: 98.45, change: 5.67 },
                    'ADA': { price: 0.52, change: -0.89 },
                    'DOT': { price: 7.23, change: 1.45 },
                    'MATIC': { price: 0.89, change: -2.12 },
                    'AVAX': { price: 35.67, change: 3.21 },
                    'LINK': { price: 15.43, change: -0.76 },
                    'UNI': { price: 7.89, change: 1.98 },
                    'ATOM': { price: 9.12, change: -1.34 }
                };
                
                cryptoData.forEach(crypto => {
                    // Use last successful price if available, otherwise use fallback
                    if (lastSuccessfulPrices[crypto.symbol]) {
                        tickerPrices[crypto.symbol] = lastSuccessfulPrices[crypto.symbol];
                    } else if (fallbackPrices[crypto.symbol]) {
                        tickerPrices[crypto.symbol] = fallbackPrices[crypto.symbol];
                    } else {
                        tickerPrices[crypto.symbol] = {
                            price: (Math.random() * 100 + 1).toFixed(2),
                            change: (Math.random() * 10 - 5).toFixed(2)
                        };
                    }
                });
                updateTicker();
                
                // If we've failed too many times, increase the update interval
                if (apiFailCount >= MAX_API_FAILS) {
                    console.log('Too many API failures, reducing update frequency');
                    // This will be handled by the update interval logic
                }
            }
        }

        // Convert Binance data to our format
        function convertBinanceData(binanceData) {
            const converted = {};
            const symbolMap = {
                'BTCUSDT': 'bitcoin',
                'ETHUSDT': 'ethereum',
                'SOLUSDT': 'solana',
                'ADAUSDT': 'cardano',
                'DOTUSDT': 'polkadot',
                'MATICUSDT': 'matic-network',
                'AVAXUSDT': 'avalanche-2',
                'LINKUSDT': 'chainlink',
                'UNIUSDT': 'uniswap',
                'ATOMUSDT': 'cosmos'
            };

            binanceData.forEach(item => {
                const coinId = symbolMap[item.symbol];
                if (coinId) {
                    const price = parseFloat(item.lastPrice);
                    const change = parseFloat(item.priceChangePercent);
                    if (price > 0) {
                        converted[coinId] = {
                            usd: price,
                            usd_24h_change: change
                        };
                    }
                }
            });

            return converted;
        }

        // Convert Coinbase data to our format
        function convertCoinbaseData(coinbaseData) {
            const converted = {};
            const symbolMap = {
                'BTC': 'bitcoin',
                'ETH': 'ethereum',
                'SOL': 'solana',
                'ADA': 'cardano',
                'DOT': 'polkadot',
                'MATIC': 'matic-network',
                'AVAX': 'avalanche-2',
                'LINK': 'chainlink',
                'UNI': 'uniswap',
                'ATOM': 'cosmos'
            };

            if (coinbaseData.data && coinbaseData.data.rates) {
                Object.keys(coinbaseData.data.rates).forEach(symbol => {
                    const coinId = symbolMap[symbol];
                    if (coinId) {
                        const rate = parseFloat(coinbaseData.data.rates[symbol]);
                        if (rate > 0) {
                            converted[coinId] = {
                                usd: rate,
                                usd_24h_change: 0 // Coinbase doesn't provide 24h change in this endpoint
                            };
                        }
                    }
                });
            }

            return converted;
        }

        function updateTicker() {
            const container = document.getElementById('tickerContainer');
            if (!container) return;

            // Create ticker items
            const tickerHTML = cryptoData.map(crypto => {
                const data = tickerPrices[crypto.symbol];
                if (!data) return '';

                const isPositive = parseFloat(data.change) >= 0;
                const changeClass = isPositive ? 'positive' : 'negative';
                const changeSymbol = isPositive ? '+' : '';

                // Format price based on value
                let formattedPrice;
                const price = parseFloat(data.price);
                if (price >= 1000) {
                    formattedPrice = '$' + price.toLocaleString('en-US', { 
                        minimumFractionDigits: 0, 
                        maximumFractionDigits: 0 
                    });
                } else if (price >= 1) {
                    formattedPrice = '$' + price.toLocaleString('en-US', { 
                        minimumFractionDigits: 2, 
                        maximumFractionDigits: 2 
                    });
                } else {
                    formattedPrice = '$' + price.toLocaleString('en-US', { 
                        minimumFractionDigits: 4, 
                        maximumFractionDigits: 4 
                    });
                }

                // Format change percentage
                const formattedChange = parseFloat(data.change).toFixed(2);

                return `
                    <div class="ticker-item">
                        <span class="ticker-symbol">${crypto.symbol}</span>
                        <span class="ticker-price">${formattedPrice}</span>
                        <span class="ticker-change ${changeClass}">${changeSymbol}${formattedChange}%</span>
                    </div>
                `;
            }).join('');

            // Duplicate the content for seamless scrolling
            container.innerHTML = tickerHTML + tickerHTML;
        }

        // Particle system for floating crypto symbols
        function initParticleSystem() {
            const particlesContainer = document.getElementById('cryptoParticles');
            if (!particlesContainer) return;
            
            const cryptoSymbols = ['₿', 'Ξ', '◎', '₳', '●', '◈', '◆', '◇', '★', '♦', '♠', '♣', '♥', '⚡', '💎', '🔗', '🔒', '🛡️', '🚀', '💫'];
            
            // Create additional particles dynamically
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = cryptoSymbols[Math.floor(Math.random() * cryptoSymbols.length)];
                
                // Random starting position
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 30 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                
                particlesContainer.appendChild(particle);
            }
            
            // Add mouse interaction for particles
            document.addEventListener('mousemove', (e) => {
                const particles = document.querySelectorAll('.particle');
                const mouseX = e.clientX;
                const mouseY = e.clientY;
                
                particles.forEach((particle, index) => {
                    const rect = particle.getBoundingClientRect();
                    const particleX = rect.left + rect.width / 2;
                    const particleY = rect.top + rect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(mouseX - particleX, 2) + Math.pow(mouseY - particleY, 2)
                    );
                    
                    if (distance < 100) {
                        particle.style.transform = `scale(1.2)`;
                        particle.style.opacity = '0.3';
                    } else {
                        particle.style.transform = 'scale(1)';
                        particle.style.opacity = '0.15';
                    }
                });
            });
        }

        // Solana Wallet Integration
        let wallet = null;
        let connection = null;
        let isWalletConnected = false;

        // Initialize Solana connection
        function initializeSolana() {
            try {
                connection = new solanaWeb3.Connection(
                    'https://api.mainnet-beta.solana.com',
                    'confirmed'
                );
                console.log('Solana connection initialized');
            } catch (error) {
                console.error('Failed to initialize Solana connection:', error);
            }
        }

        // Connect wallet function
        async function connectWallet() {
            try {
                // Check if Phantom wallet is available
                if (!window.solana || !window.solana.isPhantom) {
                    alert('Phantom wallet is not installed. Please install Phantom wallet to continue.');
                    window.open('https://phantom.app/', '_blank');
                    return;
                }

                // Request wallet connection
                const response = await window.solana.connect();
                wallet = response.publicKey;
                isWalletConnected = true;

                // Update UI
                updateWalletUI();
                
                // Check token balance
                await checkTokenBalance();

                console.log('Wallet connected:', wallet.toString());
            } catch (error) {
                console.error('Failed to connect wallet:', error);
                alert('Failed to connect wallet. Please try again.');
            }
        }

        // Disconnect wallet function
        function disconnectWallet() {
            try {
                if (window.solana) {
                    window.solana.disconnect();
                }
                wallet = null;
                isWalletConnected = false;
                updateWalletUI();
                console.log('Wallet disconnected');
            } catch (error) {
                console.error('Failed to disconnect wallet:', error);
            }
        }

        // Update wallet UI
        function updateWalletUI() {
            const connectBtn = document.getElementById('connectBtn');
            const heroConnectBtn = document.getElementById('heroConnectBtn');
            const walletStatus = document.getElementById('walletStatus');
            
            if (isWalletConnected && wallet) {
                const shortAddress = wallet.toString().slice(0, 4) + '...' + wallet.toString().slice(-4);
                connectBtn.innerHTML = `
                    <span class="hidden sm:inline">${shortAddress}</span>
                    <span class="sm:hidden">${shortAddress}</span>
                `;
                connectBtn.onclick = disconnectWallet;
                connectBtn.className = 'bg-secondary border border-primary text-primary px-4 md:px-6 py-2 rounded-lg font-semibold shadow-sm hover:bg-primary hover:text-black transition-colors focus:outline-none focus:ring-2 focus:ring-primary text-sm md:text-base';
                
                if (heroConnectBtn) {
                    heroConnectBtn.innerHTML = `
                        <span class="hidden sm:inline">${shortAddress}</span>
                        <span class="sm:hidden">${shortAddress}</span>
                    `;
                    heroConnectBtn.onclick = disconnectWallet;
                    heroConnectBtn.className = 'bg-secondary border border-primary text-primary px-6 md:px-8 py-3 md:py-4 rounded-lg text-lg md:text-xl font-bold shadow-sm hover:bg-primary hover:text-black transition-colors focus:outline-none focus:ring-2 focus:ring-primary border-transparent font-grotesk w-full sm:w-auto';
                }
                
                // Update wallet status in full chat
                if (walletStatus) {
                    walletStatus.innerHTML = `
                        <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                        <span class="text-sm text-green-500 font-semibold">${shortAddress}</span>
                    `;
                }
            } else {
                connectBtn.innerHTML = `
                    <span class="hidden sm:inline">Connect Wallet</span>
                    <span class="sm:hidden">Connect</span>
                `;
                connectBtn.onclick = connectWallet;
                connectBtn.className = 'bg-primary text-black px-4 md:px-6 py-2 rounded-lg font-semibold shadow-sm hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary border border-transparent text-sm md:text-base';
                
                if (heroConnectBtn) {
                    heroConnectBtn.innerHTML = 'Connect Wallet';
                    heroConnectBtn.onclick = connectWallet;
                    heroConnectBtn.className = 'bg-primary text-black px-6 md:px-8 py-3 md:py-4 rounded-lg text-lg md:text-xl font-bold shadow-sm hover:bg-primary/90 transition-colors focus:outline-none focus:ring-2 focus:ring-primary border border-transparent font-grotesk w-full sm:w-auto';
                }
                
                // Update wallet status in full chat
                if (walletStatus) {
                    walletStatus.innerHTML = `
                        <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                        <span class="text-sm text-red-500 font-semibold">Wallet Disconnected</span>
                    `;
                }
            }
        }

        // Check GPTARD token balance
        async function checkTokenBalance() {
            if (!wallet || !connection) return;

            try {
                // GPTARD token mint address (replace with actual token mint)
                const tokenMint = new solanaWeb3.PublicKey('YOUR_GPTARD_TOKEN_MINT_ADDRESS');
                
                // Get token accounts
                const tokenAccounts = await connection.getParsedTokenAccountsByOwner(wallet, {
                    mint: tokenMint
                });

                if (tokenAccounts.value.length > 0) {
                    const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
                    console.log('GPTARD balance:', balance);
                    
                    // Enable chat if user has tokens
                    if (balance > 0) {
                        enableChatAccess();
                    } else {
                        disableChatAccess();
                    }
                } else {
                    disableChatAccess();
                }
            } catch (error) {
                console.error('Failed to check token balance:', error);
                // For demo purposes, enable chat access
                enableChatAccess();
            }
        }

        // Enable chat access
        function enableChatAccess() {
            const chatButtons = document.querySelectorAll('[onclick*="openFullChat"]');
            chatButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            });
            
            // Show success message
            showNotification('Wallet connected! Chat access granted.', 'success');
        }

        // Disable chat access
        function disableChatAccess() {
            const chatButtons = document.querySelectorAll('[onclick*="openFullChat"]');
            chatButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            });
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `fixed top-20 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full`;
            
            const bgColor = type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600';
            notification.className += ` ${bgColor} text-white`;
            
            notification.innerHTML = `
                <div class="flex items-center space-x-2">
                    <span>${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Watchlist Functionality
        let watchlistData = [
            {
                address: '9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM',
                lastTokens: ['BONK', 'WIF', 'POPCAT'],
                lastTxTime: '2 minutes ago',
                id: 1
            },
            {
                address: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU',
                lastTokens: ['JUP', 'RAY', 'SRM'],
                lastTxTime: '5 minutes ago',
                id: 2
            },
            {
                address: '3XwxHcbyqcd1xkBExFyLpLqXJqJqJqJqJqJqJqJqJqJq',
                lastTokens: ['SOL', 'USDC', 'ETH'],
                lastTxTime: '12 minutes ago',
                id: 3
            },
            {
                address: '5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1',
                lastTokens: ['GPTARD', 'BONK', 'WIF'],
                lastTxTime: '18 minutes ago',
                id: 4
            },
            {
                address: '2xNweLHLqrxmQZbqQJqJqJqJqJqJqJqJqJqJqJqJqJqJq',
                lastTokens: ['POPCAT', 'BOME', 'DOGWIFHAT'],
                lastTxTime: '25 minutes ago',
                id: 5
            }
        ];

        // Initialize watchlist
        function initializeWatchlist() {
            // Load watchlist from localStorage
            const savedWatchlist = localStorage.getItem('gptardWatchlist');
            if (savedWatchlist) {
                watchlistData = JSON.parse(savedWatchlist);
                renderWatchlist();
                
                // Refresh data for existing wallets
                refreshAllWalletData();
            } else {
                renderWatchlist();
            }
        }

        // Refresh all wallet data in watchlist
        async function refreshAllWalletData() {
            const refreshButton = document.querySelector('button[onclick="refreshAllWalletData()"]');
            const originalContent = refreshButton.innerHTML;
            
            // Show loading state
            refreshButton.innerHTML = `
                <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-black"></div>
                <span>Refreshing...</span>
            `;
            refreshButton.disabled = true;
            
            try {
                showNotification('Refreshing wallet data...', 'info');
                
                for (let wallet of watchlistData) {
                    try {
                        await fetchWalletData(wallet);
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } catch (error) {
                        console.error(`Failed to refresh wallet ${wallet.address}:`, error);
                    }
                }
                
                renderWatchlist();
                showNotification('Wallet data refreshed successfully', 'success');
            } catch (error) {
                console.error('Failed to refresh wallet data:', error);
                showNotification('Failed to refresh wallet data', 'error');
            } finally {
                // Restore button state
                refreshButton.innerHTML = originalContent;
                refreshButton.disabled = false;
            }
        }

        // Auto-refresh wallet data every 5 minutes
        setInterval(() => {
            if (watchlistData.length > 0) {
                console.log('Auto-refreshing wallet data...');
                refreshAllWalletData();
            }
        }, 5 * 60 * 1000); // 5 minutes

        // Render watchlist table
        function renderWatchlist() {
            const tableBody = document.getElementById('watchlistTableBody');
            if (!tableBody) return;

            tableBody.innerHTML = watchlistData.map(wallet => `
                <tr class="border-b border-muted hover:bg-muted/30 transition-colors">
                    <td class="px-6 py-4">
                        <div class="flex items-center space-x-2">
                            <div class="w-2 h-2 ${wallet.lastTokens.includes('Loading...') ? 'bg-yellow-500 animate-pulse' : 'bg-green-500'} rounded-full"></div>
                            <span class="font-mono text-sm text-gray-300">${wallet.address.slice(0, 4)}...${wallet.address.slice(-4)}</span>
                            <button onclick="copyToClipboard('${wallet.address}')" class="text-gray-400 hover:text-primary transition-colors" title="Copy address">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                </svg>
                            </button>
                        </div>
                        ${wallet.balance ? `<div class="text-xs text-gray-500 mt-1">Balance: ${wallet.balance}</div>` : ''}
                    </td>
                    <td class="px-6 py-4">
                        <div class="flex flex-wrap gap-1">
                            ${wallet.lastTokens.map(token => `
                                <span class="bg-muted px-2 py-1 rounded text-xs font-semibold text-gray-300">${token}</span>
                            `).join('')}
                        </div>
                    </td>
                    <td class="px-6 py-4">
                        <span class="text-sm text-gray-400">${wallet.lastTxTime}</span>
                    </td>
                    <td class="px-6 py-4">
                        <span class="text-sm text-gray-400">${wallet.transactionCount || 'Unknown'}</span>
                    </td>
                    <td class="px-6 py-4">
                        <div class="flex space-x-2">
                            <button onclick="analyzeWallet('${wallet.address}')" class="bg-primary text-black px-3 py-1 rounded text-xs font-semibold hover:bg-primary/90 transition-colors">
                                Analyze
                            </button>
                            <button onclick="removeFromWatchlist(${wallet.id})" class="bg-red-600 text-white px-3 py-1 rounded text-xs font-semibold hover:bg-red-700 transition-colors">
                                Remove
                            </button>
                        </div>
                    </td>
                </tr>
            `).join('');
        }

        // Add wallet to watchlist
        async function addWalletToWatchlist() {
            const walletInput = document.getElementById('walletInput');
            const address = walletInput.value.trim();

            if (!address) {
                showNotification('Please enter a wallet address', 'error');
                return;
            }

            // Basic Solana address validation (44 characters, base58)
            if (address.length !== 44 || !/^[1-9A-HJ-NP-Za-km-z]+$/.test(address)) {
                showNotification('Please enter a valid Solana wallet address', 'error');
                return;
            }

            // Check if wallet already exists
            if (watchlistData.some(wallet => wallet.address === address)) {
                showNotification('Wallet already in watchlist', 'error');
                return;
            }

            // Add new wallet with loading state
            const newWallet = {
                address: address,
                lastTokens: ['Loading...', 'Loading...', 'Loading...'],
                lastTxTime: 'Just added',
                id: Date.now()
            };

            watchlistData.unshift(newWallet);
            renderWatchlist();
            saveWatchlistToStorage();
            walletInput.value = '';
            
            showNotification('Wallet added to watchlist', 'success');

            // Fetch real wallet data
            try {
                await fetchWalletData(newWallet);
            } catch (error) {
                console.error('Failed to fetch wallet data:', error);
                // Fallback to mock data if API fails
                const mockTokens = ['SOL', 'USDC', 'BONK', 'WIF', 'JUP', 'RAY', 'SRM', 'GPTARD', 'POPCAT', 'BOME'];
                const randomTokens = [];
                for (let i = 0; i < 3; i++) {
                    const randomToken = mockTokens[Math.floor(Math.random() * mockTokens.length)];
                    if (!randomTokens.includes(randomToken)) {
                        randomTokens.push(randomToken);
                    }
                }
                
                newWallet.lastTokens = randomTokens;
                newWallet.lastTxTime = '1 minute ago';
                renderWatchlist();
            }
        }

        // Fetch real wallet data from Solana APIs
        async function fetchWalletData(wallet) {
            try {
                // Try multiple APIs for better reliability
                let walletData = null;

                // First try Helius API (if you have an API key)
                try {
                    const response = await fetch(`https://api.helius.xyz/v0/addresses/${wallet.address}/transactions?api-key=YOUR_HELIUS_API_KEY`, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        walletData = processHeliusData(data);
                        console.log('Using Helius API for wallet data');
                    }
                } catch (error) {
                    console.log('Helius API failed, trying alternative...');
                }

                // If Helius fails, try Solana RPC
                if (!walletData) {
                    try {
                        const response = await fetch('https://api.mainnet-beta.solana.com', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "jsonrpc": "2.0",
                                "id": 1,
                                "method": "getSignaturesForAddress",
                                "params": [
                                    wallet.address,
                                    {
                                        "limit": 10
                                    }
                                ]
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            walletData = processSolanaRPCData(data);
                            console.log('Using Solana RPC for wallet data');
                        }
                    } catch (error) {
                        console.log('Solana RPC failed, trying third option...');
                    }
                }

                // If both fail, try public API
                if (!walletData) {
                    try {
                        const response = await fetch(`https://public-api.solscan.io/account/transactions?account=${wallet.address}&limit=10`);
                        
                        if (response.ok) {
                            const data = await response.json();
                            walletData = processSolscanData(data);
                            console.log('Using Solscan API for wallet data');
                        }
                    } catch (error) {
                        console.log('All APIs failed, using fallback data');
                        throw new Error('All wallet APIs failed');
                    }
                }

                if (walletData) {
                    // Update wallet with real data
                    wallet.lastTokens = walletData.tokens;
                    wallet.lastTxTime = walletData.lastTxTime;
                    wallet.balance = walletData.balance;
                    wallet.transactionCount = walletData.transactionCount;
                    renderWatchlist();
                }

            } catch (error) {
                console.error('Failed to fetch wallet data:', error);
                throw error;
            }
        }

        // Process Helius API data
        function processHeliusData(data) {
            const tokens = [];
            const tokenMap = {
                'So11111111111111111111111111111111111111112': 'SOL',
                'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
                'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'BONK',
                'EKpQGSJtjMFqKZ1KQanSqYXRcF8fBopzLHYxdM65Qjmz': 'WIF',
                'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN': 'JUP',
                '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R': 'RAY',
                'SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt': 'SRM',
                'GPTARD_TOKEN_MINT': 'GPTARD',
                'POPCAT_TOKEN_MINT': 'POPCAT',
                'BOME_TOKEN_MINT': 'BOME'
            };

            // Extract tokens from recent transactions
            if (data && data.length > 0) {
                data.slice(0, 5).forEach(tx => {
                    if (tx.tokenTransfers && tx.tokenTransfers.length > 0) {
                        tx.tokenTransfers.forEach(transfer => {
                            const tokenSymbol = tokenMap[transfer.mint] || transfer.mint.slice(0, 4);
                            if (!tokens.includes(tokenSymbol)) {
                                tokens.push(tokenSymbol);
                            }
                        });
                    }
                });
            }

            return {
                tokens: tokens.length > 0 ? tokens.slice(0, 3) : ['SOL', 'USDC', 'BONK'],
                lastTxTime: data && data.length > 0 ? formatTimeAgo(new Date(data[0].timestamp * 1000)) : 'Unknown',
                balance: 'Loading...',
                transactionCount: data ? data.length : 0
            };
        }

        // Process Solana RPC data
        function processSolanaRPCData(data) {
            const tokens = ['SOL', 'USDC', 'BONK']; // Default tokens for RPC data
            
            return {
                tokens: tokens,
                lastTxTime: data && data.result && data.result.length > 0 ? 
                    formatTimeAgo(new Date(data.result[0].blockTime * 1000)) : 'Unknown',
                balance: 'Loading...',
                transactionCount: data && data.result ? data.result.length : 0
            };
        }

        // Process Solscan data
        function processSolscanData(data) {
            const tokens = [];
            const tokenMap = {
                'So11111111111111111111111111111111111111112': 'SOL',
                'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
                'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'BONK',
                'EKpQGSJtjMFqKZ1KQanSqYXRcF8fBopzLHYxdM65Qjmz': 'WIF'
            };

            if (data && data.data && data.data.length > 0) {
                data.data.slice(0, 5).forEach(tx => {
                    if (tx.tokenTransfers && tx.tokenTransfers.length > 0) {
                        tx.tokenTransfers.forEach(transfer => {
                            const tokenSymbol = tokenMap[transfer.mint] || transfer.mint.slice(0, 4);
                            if (!tokens.includes(tokenSymbol)) {
                                tokens.push(tokenSymbol);
                            }
                        });
                    }
                });
            }

            return {
                tokens: tokens.length > 0 ? tokens.slice(0, 3) : ['SOL', 'USDC', 'BONK'],
                lastTxTime: data && data.data && data.data.length > 0 ? 
                    formatTimeAgo(new Date(data.data[0].blockTime * 1000)) : 'Unknown',
                balance: 'Loading...',
                transactionCount: data && data.data ? data.data.length : 0
            };
        }

        // Format time ago
        function formatTimeAgo(date) {
            const now = new Date();
            const diffInSeconds = Math.floor((now - date) / 1000);
            
            if (diffInSeconds < 60) {
                return `${diffInSeconds} seconds ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.floor(diffInSeconds / 60);
                return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.floor(diffInSeconds / 3600);
                return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            } else {
                const days = Math.floor(diffInSeconds / 86400);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            }
        }

        // Remove wallet from watchlist
        function removeFromWatchlist(id) {
            watchlistData = watchlistData.filter(wallet => wallet.id !== id);
            renderWatchlist();
            saveWatchlistToStorage();
            showNotification('Wallet removed from watchlist', 'success');
        }

        // Save watchlist to localStorage
        function saveWatchlistToStorage() {
            localStorage.setItem('gptardWatchlist', JSON.stringify(watchlistData));
        }

        // Analyze wallet
        async function analyzeWallet(address) {
            showNotification(`Analyzing wallet ${address.slice(0, 4)}...${address.slice(-4)}`, 'info');
            
            try {
                // Fetch real wallet analysis data
                const analysisData = await fetchWalletAnalysis(address);
                if (analysisData) {
                    // Merge real data with generated data for comprehensive analysis
                    const analysis = generateWalletAnalysis(address, analysisData);
                    showWalletAnalysisModal(analysis);
                } else {
                    // Fallback to mock data if no real data available
                    setTimeout(() => {
                        const analysis = generateWalletAnalysis(address);
                        showWalletAnalysisModal(analysis);
                    }, 1000);
                }
            } catch (error) {
                console.error('Failed to fetch wallet analysis:', error);
                // Fallback to mock data
                setTimeout(() => {
                    const analysis = generateWalletAnalysis(address);
                    showWalletAnalysisModal(analysis);
                }, 1000);
            }
        }

        // Fetch real wallet analysis data
        async function fetchWalletAnalysis(address) {
            try {
                // Try to get detailed wallet data from multiple sources
                let analysisData = null;

                // Try Solscan for detailed account info
                try {
                    const accountResponse = await fetch(`https://public-api.solscan.io/account/${address}`);
                    if (accountResponse.ok) {
                        const accountData = await accountResponse.json();
                        analysisData = processAccountData(accountData);
                    }
                } catch (error) {
                    console.log('Solscan account API failed');
                }

                // Try to get recent transactions for trade analysis
                try {
                    const txResponse = await fetch(`https://public-api.solscan.io/account/transactions?account=${address}&limit=50`);
                    if (txResponse.ok) {
                        const txData = await txResponse.json();
                        const txAnalysis = processTransactionData(txData);
                        
                        if (analysisData) {
                            analysisData = { ...analysisData, ...txAnalysis };
                        } else {
                            analysisData = txAnalysis;
                        }
                    }
                } catch (error) {
                    console.log('Solscan transaction API failed');
                }

                // If no data from Solscan, try Solana RPC
                if (!analysisData) {
                    try {
                        const response = await fetch('https://api.mainnet-beta.solana.com', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "jsonrpc": "2.0",
                                "id": 1,
                                "method": "getAccountInfo",
                                "params": [
                                    address,
                                    {
                                        "encoding": "jsonParsed"
                                    }
                                ]
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            analysisData = processRPCAccountData(data);
                        }
                    } catch (error) {
                        console.log('Solana RPC failed for analysis');
                    }
                }

                return analysisData;

            } catch (error) {
                console.error('Failed to fetch wallet analysis:', error);
                throw error;
            }
        }

        // Process account data from Solscan
        function processAccountData(data) {
            return {
                balance: data.lamports ? (data.lamports / 1e9).toFixed(4) + ' SOL' : 'Unknown',
                transactionCount: data.txCount || 0,
                accountType: data.type || 'Unknown',
                createdAt: data.createdAt ? new Date(data.createdAt).toLocaleDateString() : 'Unknown'
            };
        }

        // Process transaction data for trade analysis
        function processTransactionData(data) {
            if (!data.data || data.data.length === 0) {
                return {
                    recentTrades: [],
                    successRate: 'Unknown',
                    avgTradeSize: 'Unknown',
                    riskLevel: 'Unknown'
                };
            }

            const trades = data.data.slice(0, 20).map(tx => ({
                type: tx.type || 'Unknown',
                amount: tx.amount || 'Unknown',
                timestamp: tx.blockTime ? new Date(tx.blockTime * 1000).toLocaleString() : 'Unknown',
                success: tx.status === 'Success'
            }));

            const successfulTrades = trades.filter(trade => trade.success);
            const successRate = trades.length > 0 ? Math.round((successfulTrades.length / trades.length) * 100) : 0;

            return {
                recentTrades: trades.slice(0, 10),
                successRate: `${successRate}%`,
                avgTradeSize: 'Calculating...',
                riskLevel: successRate > 80 ? 'Low' : successRate > 60 ? 'Medium' : 'High'
            };
        }

        // Process RPC account data
        function processRPCAccountData(data) {
            return {
                balance: data.result && data.result.value ? 
                    (data.result.value.lamports / 1e9).toFixed(4) + ' SOL' : 'Unknown',
                transactionCount: 'Unknown',
                accountType: 'Unknown',
                createdAt: 'Unknown',
                recentTrades: [],
                successRate: 'Unknown',
                avgTradeSize: 'Unknown',
                riskLevel: 'Unknown'
            };
        }

        // Generate comprehensive wallet analysis
        function generateWalletAnalysis(address, realData = null) {
            // Use real data if available, otherwise generate mock data
            const totalValue = realData && realData.balance !== 'Unknown' ? 
                parseFloat(realData.balance) * 100 + Math.random() * 50000 : 
                Math.random() * 1000000 + 10000;
            
            const tokenCount = Math.floor(Math.random() * 50 + 5);
            const transactionCount = realData && realData.transactionCount !== 'Unknown' ? 
                realData.transactionCount : 
                Math.floor(Math.random() * 1000 + 100);
            
            const riskLevel = realData && realData.riskLevel !== 'Unknown' ? 
                realData.riskLevel : 
                ['Low', 'Medium', 'High'][Math.floor(Math.random() * 3)];
            
            // Generate mock token holdings
            const tokens = ['SOL', 'USDC', 'BONK', 'WIF', 'JUP', 'RAY', 'SRM', 'GPTARD', 'POPCAT', 'BOME', 'DOGWIFHAT', 'SAMO', 'ORCA', 'MNGO', 'SRM'];
            const holdings = [];
            
            for (let i = 0; i < tokenCount; i++) {
                const token = tokens[Math.floor(Math.random() * tokens.length)];
                const amount = Math.random() * 10000 + 100;
                const value = Math.random() * 50000 + 1000;
                const change24h = (Math.random() * 40 - 20).toFixed(2);
                
                if (!holdings.find(h => h.symbol === token)) {
                    holdings.push({
                        symbol: token,
                        amount: amount.toFixed(2),
                        value: value.toFixed(2),
                        change24h: parseFloat(change24h)
                    });
                }
            }

            // Generate mock trade history
            const tradeHistory = [];
            const tradeTypes = ['Buy', 'Sell'];
            const tradeTokens = ['SOL', 'BONK', 'WIF', 'JUP', 'GPTARD', 'POPCAT'];
            
            for (let i = 0; i < 20; i++) {
                const type = tradeTypes[Math.floor(Math.random() * tradeTypes.length)];
                const token = tradeTokens[Math.floor(Math.random() * tradeTokens.length)];
                const amount = Math.random() * 1000 + 10;
                const price = Math.random() * 100 + 1;
                const timestamp = new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000); // Last 30 days
                const pnl = type === 'Sell' ? (Math.random() * 2000 - 1000) : 0; // Only sells have P&L
                
                tradeHistory.push({
                    type: type,
                    token: token,
                    amount: amount.toFixed(2),
                    price: price.toFixed(4),
                    timestamp: timestamp,
                    pnl: pnl.toFixed(2),
                    success: pnl > 0
                });
            }

            // Calculate overall P&L
            const totalPnL = tradeHistory.reduce((sum, trade) => sum + parseFloat(trade.pnl), 0);
            const successfulTrades = tradeHistory.filter(trade => trade.success).length;
            const totalTrades = tradeHistory.filter(trade => trade.type === 'Sell').length;
            
            // Use real success rate if available, otherwise calculate from mock data
            const successRate = realData && realData.successRate !== 'Unknown' ? 
                realData.successRate : 
                (totalTrades > 0 ? (successfulTrades / totalTrades * 100).toFixed(1) : 0);

            // Find most and least successful trades
            const sellTrades = tradeHistory.filter(trade => trade.type === 'Sell');
            const mostSuccessful = sellTrades.reduce((max, trade) => 
                parseFloat(trade.pnl) > parseFloat(max.pnl) ? trade : max, sellTrades[0] || { pnl: 0 });
            const leastSuccessful = sellTrades.reduce((min, trade) => 
                parseFloat(trade.pnl) < parseFloat(min.pnl) ? trade : min, sellTrades[0] || { pnl: 0 });

            return {
                address: address,
                totalValue: totalValue.toFixed(2),
                tokenCount: tokenCount,
                transactionCount: transactionCount,
                riskLevel: riskLevel,
                holdings: holdings,
                tradeHistory: tradeHistory,
                totalPnL: totalPnL.toFixed(2),
                successRate: successRate,
                mostSuccessful: mostSuccessful,
                leastSuccessful: leastSuccessful,
                analysisDate: new Date().toLocaleString()
            };
        }

        // Show wallet analysis modal
        function showWalletAnalysisModal(analysis) {
            // Remove existing modal if any
            const existingModal = document.getElementById('walletAnalysisModal');
            if (existingModal) {
                existingModal.remove();
            }

            const modal = document.createElement('div');
            modal.id = 'walletAnalysisModal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
            modal.innerHTML = `
                <div class="bg-secondary rounded-xl border border-muted shadow-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
                    <div class="p-6 border-b border-muted">
                        <div class="flex justify-between items-center">
                            <h2 class="text-2xl font-bold font-grotesk">Wallet Analysis</h2>
                            <button onclick="closeWalletAnalysisModal()" class="text-gray-400 hover:text-white transition-colors">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <p class="text-gray-400 mt-2">${analysis.address.slice(0, 4)}...${analysis.address.slice(-4)} • Analyzed ${analysis.analysisDate}</p>
                    </div>
                    
                    <div class="p-6 space-y-6">
                        <!-- Overview Stats -->
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div class="bg-muted rounded-lg p-4">
                                <div class="text-sm text-gray-400">Total Value</div>
                                <div class="text-xl font-bold text-primary">$${analysis.totalValue}</div>
                            </div>
                            <div class="bg-muted rounded-lg p-4">
                                <div class="text-sm text-gray-400">Total P&L</div>
                                <div class="text-xl font-bold ${parseFloat(analysis.totalPnL) >= 0 ? 'text-green-500' : 'text-red-500'}">$${analysis.totalPnL}</div>
                            </div>
                            <div class="bg-muted rounded-lg p-4">
                                <div class="text-sm text-gray-400">Success Rate</div>
                                <div class="text-xl font-bold text-accent">${analysis.successRate}%</div>
                            </div>
                            <div class="bg-muted rounded-lg p-4">
                                <div class="text-sm text-gray-400">Risk Level</div>
                                <div class="text-xl font-bold ${analysis.riskLevel === 'Low' ? 'text-green-500' : analysis.riskLevel === 'Medium' ? 'text-yellow-500' : 'text-red-500'}">${analysis.riskLevel}</div>
                            </div>
                        </div>

                        <!-- Holdings -->
                        <div>
                            <h3 class="text-lg font-bold mb-4">Token Holdings (${analysis.holdings.length})</h3>
                            <div class="bg-muted rounded-lg overflow-hidden">
                                <div class="overflow-x-auto">
                                    <table class="w-full">
                                        <thead class="bg-secondary">
                                            <tr>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Token</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Amount</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Value</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">24h Change</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${analysis.holdings.map(holding => `
                                                <tr class="border-b border-gray-700">
                                                    <td class="px-4 py-3">
                                                        <span class="font-semibold">${holding.symbol}</span>
                                                    </td>
                                                    <td class="px-4 py-3">${holding.amount}</td>
                                                    <td class="px-4 py-3">$${holding.value}</td>
                                                    <td class="px-4 py-3">
                                                        <span class="${holding.change24h >= 0 ? 'text-green-500' : 'text-red-500'}">
                                                            ${holding.change24h >= 0 ? '+' : ''}${holding.change24h}%
                                                        </span>
                                                    </td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>

                        <!-- Trade History -->
                        <div>
                            <h3 class="text-lg font-bold mb-4">Recent Trades (${analysis.tradeHistory.length})</h3>
                            <div class="bg-muted rounded-lg overflow-hidden">
                                <div class="overflow-x-auto">
                                    <table class="w-full">
                                        <thead class="bg-secondary">
                                            <tr>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Type</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Token</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Amount</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Price</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">P&L</th>
                                                <th class="px-4 py-3 text-left text-sm font-semibold text-gray-300">Date</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${analysis.tradeHistory.slice(0, 10).map(trade => `
                                                <tr class="border-b border-gray-700">
                                                    <td class="px-4 py-3">
                                                        <span class="px-2 py-1 rounded text-xs font-semibold ${trade.type === 'Buy' ? 'bg-blue-600 text-white' : 'bg-purple-600 text-white'}">
                                                            ${trade.type}
                                                        </span>
                                                    </td>
                                                    <td class="px-4 py-3 font-semibold">${trade.token}</td>
                                                    <td class="px-4 py-3">${trade.amount}</td>
                                                    <td class="px-4 py-3">$${trade.price}</td>
                                                    <td class="px-4 py-3">
                                                        <span class="${trade.pnl >= 0 ? 'text-green-500' : 'text-red-500'}">
                                                            ${trade.pnl >= 0 ? '+' : ''}$${trade.pnl}
                                                        </span>
                                                    </td>
                                                    <td class="px-4 py-3 text-sm text-gray-400">
                                                        ${trade.timestamp.toLocaleDateString()}
                                                    </td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>

                        <!-- Best/Worst Trades -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-muted rounded-lg p-4">
                                <h4 class="text-lg font-bold mb-3 text-green-500">Most Successful Trade</h4>
                                ${analysis.mostSuccessful.token ? `
                                    <div class="space-y-2">
                                        <div><span class="text-gray-400">Token:</span> <span class="font-semibold">${analysis.mostSuccessful.token}</span></div>
                                        <div><span class="text-gray-400">Amount:</span> <span class="font-semibold">${analysis.mostSuccessful.amount}</span></div>
                                        <div><span class="text-gray-400">P&L:</span> <span class="font-semibold text-green-500">+$${analysis.mostSuccessful.pnl}</span></div>
                                        <div><span class="text-gray-400">Date:</span> <span class="font-semibold">${analysis.mostSuccessful.timestamp.toLocaleDateString()}</span></div>
                                    </div>
                                ` : '<p class="text-gray-400">No sell trades found</p>'}
                            </div>
                            <div class="bg-muted rounded-lg p-4">
                                <h4 class="text-lg font-bold mb-3 text-red-500">Least Successful Trade</h4>
                                ${analysis.leastSuccessful.token ? `
                                    <div class="space-y-2">
                                        <div><span class="text-gray-400">Token:</span> <span class="font-semibold">${analysis.leastSuccessful.token}</span></div>
                                        <div><span class="text-gray-400">Amount:</span> <span class="font-semibold">${analysis.leastSuccessful.amount}</span></div>
                                        <div><span class="text-gray-400">P&L:</span> <span class="font-semibold text-red-500">$${analysis.leastSuccessful.pnl}</span></div>
                                        <div><span class="text-gray-400">Date:</span> <span class="font-semibold">${analysis.leastSuccessful.timestamp.toLocaleDateString()}</span></div>
                                    </div>
                                ` : '<p class="text-gray-400">No sell trades found</p>'}
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeWalletAnalysisModal();
                }
            });
        }

        // Close wallet analysis modal
        function closeWalletAnalysisModal() {
            const modal = document.getElementById('walletAnalysisModal');
            if (modal) {
                modal.remove();
            }
        }

        // Copy to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Address copied to clipboard', 'success');
            }).catch(() => {
                showNotification('Failed to copy address', 'error');
            });
        }

        // Initialize animations on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Solana connection
            initializeSolana();
            
            // Trigger initial fade-in for hero section
            setTimeout(() => {
                document.querySelector('.section-fade').classList.add('visible');
            }, 100);

            // Initialize mobile optimizations
            initMobileOptimizations();
            
            // Initialize crypto ticker
            fetchCryptoPrices();
            
            // Initialize particle system
            initParticleSystem();
            
            // Initialize watchlist
            initializeWatchlist();
            
            // Adaptive update interval based on API success/failure
            let updateInterval = 15000; // Start with 15 seconds
            let updateTimer = null;

            function startPriceUpdates() {
                if (updateTimer) {
                    clearInterval(updateTimer);
                }
                
                // Adjust interval based on API failure count
                if (apiFailCount >= MAX_API_FAILS) {
                    updateInterval = 60000; // 1 minute if many failures
                } else if (apiFailCount >= 2) {
                    updateInterval = 30000; // 30 seconds if some failures
                } else {
                    updateInterval = 15000; // 15 seconds if working well
                }
                
                updateTimer = setInterval(fetchCryptoPrices, updateInterval);
                console.log(`Price updates set to ${updateInterval/1000} seconds`);
            }

            // Start initial updates
            startPriceUpdates();
            
            // Also update immediately when page becomes visible
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    fetchCryptoPrices();
                    startPriceUpdates(); // Restart with current failure count
                }
            });
        });
    </script>
</body>
</html> 